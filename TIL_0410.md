## 2023.04.10 (월)


> 오늘 면접을 봤는데, 코테에서 피보나치 순열이 출제되었다.
> 그러고 면접 끝나고 데브코스 과정 보는데 피부나치 순열이…ㅋㅋㅋㅋ 🥲 이래서 기초가 중요한가보다.
> 망각했어..
> 기초를 충실히 하자!!!!!!!


##  선형 배열 Point

####  List.insert(index, 대상 값)

```
 L.index(3, 65)
```
* index 3번째 위치에 65를 삽입해라

#### 궁금증
* append 메소드와 insert 메소드의 차이는 무엇일까?

* del 과 pop의 차이는 무엇일까?

---

## 정렬
* `sorted()`
    
    * 내장 함수 (built-in function)
    * 정렬된 새로운 리스트를 얻어냄
    * 역순 방법 -> ```L2 = sorted(L, reverse = True)```

* `sort()`

    * 리스트의 메서드 (method)
    * 해당 리스트를 정렬함
    * 역순 방법 -> ```L.sort(reverse=True)```

#### 정렬에 조건 주는 방법
```
L = ['abcd' , 'xyz' , 'spam']
sorted(L, key = lambda x: len(x))
```
* 결과 : `['xyz', 'abcd', 'spam']

```python
L = [{'name' : 'John', 'score' : 83}, {'name' : 'Paul', 'score' : 92}]
L.sort(key = lambda x : x['score'], reverse = True)
```
* 레코드들을 점수 높은 순으로 정렬

## 탐색 알고리즘

### 선형 탐색 알고리즘 (Linear Search)
* 리스트의 길이에 비례하는 시간 소요 : `O(n)`
    * 최악의 경우 : 모든 원소를 다 비교해야 한다

### 이진 탐색 알고리즘 (Binary Serach)
* 탐색하려는 리스트가 이미 정렬되어 있는 경우에만 적용 가능
* 크기 순으로 정렬되어 있다는 성질을 이용
* 한 번 비교가 일어날 때마다 리스트를 반씩 줄임
    * `O(logn)`
```python
def solution(L, x):
    answer = 0
    
    start, end = 0, len(L)-1
    
    while start <= end :
        middle = (start + end) // 2         # 중간값 찾기
        
        if L[middle] == x :
            return middle
        elif L[middle] < x: 
            # start보다 작으면
            start = middle +1
        else :
            end = middle - 1
    
    return -1
```

## 재귀 알고리즘 - 기초 (Recursive functions)

* 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것
* 생각보다 많은 종류의 문제를 재귀적으로 해결 가능

* 이진트리
    * 노드 기준
    * 왼쪽 서브트리의 원소들은 모두 작거나 같을 것
    * 오른쪽 서브트리의 원소들은 모두 클 것
    * 이 원칙은 모두 노드들에 재귀적으로 적용 가능

* 수학 공식을 이용해서 생각해보기
```python
def sum(n) : 
    # 0 미만의 수는 자기 자신
    if n <= 1 :
        return n
    # 양수만
    else :
        return n + sum(n-1)
```
> 재귀 함수를 호출 할 때 종결 조건이 매우 중요하다!!    
알고리즘의 종결조건에 반드시 필요하다!!

## 피보나치 순열 구현하기
```python
def solution(x):
    answer = 0
    
    def fibo(x) :
        if x == 0 :
            return 0
        elif x == 1 : 
            return 1
        else :
            return fibo(x-1) + fibo(x-2)
    answer = fibo(x)
    return answer
```

## 재귀 알고리즘 응용

* 재귀적이 반복된다는 점에서 count 파트에서 약점을 갖는다.

### 조합의 수 계산
* n개의 서로 다른 원소에서 m개를 택하는 경우의 수


----
## 알고리즘 복잡도

* 시간 복잡도 : 문제의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계
* 공간 복잡도 : 문제의 크기와 이를 해결하는 데 필요한 메모리 공간 사이의 관계


### 평균 시간 복잡도
임의의 입력 패턴을 가정했을 때 소요되는 시간의 평균
### 최악 시간 복잡도
가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간
### Big-O 표기법
점근 표기법
* 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현
    * 알고리즘의 복잡도를 표현할 때 흔히 쓰임
    * `O(logn), O(n), O(n^2), O(2^n)`
    * 입력의 크기가 n일 때 비례하는 시간 명시
    * 계수는 그다지 중요하지 않다.

선형 시간 알고리즘 - O(n) 
* 예 : n개의 무작위로 나열된 수에서 최댓값을 찾기 위해 선형 탐색 알고리즘 적용

로그 시간 알고리즘 - O(logn)
* n의 크기 순으로 정렬된 수에서 특정 값을 찾기 위해 이진탐색 알고리즘 적용

이차 시간 알고리즘 - O(n^2)

보다 나은 (낮은) 복잡도를 가지는 정렬 알고리즘
-> 병합 정렬 (merge sort) -> `O(nlogn)
* 입력 패턴에 따라 정렬 속도에 차이가 있지만, 정렬 문제에 대해 `O(nlogn)` 이 동작하는 방법에 대해 이해












